%% name = Vish
%% {
  attr_accessor :result
}

space = " "
- = space*
nl = "\n"
not_nl = /[^\n]/
redirect_op = < /<|>(>|&2)?|>&2|2>&1|2>/ > { text }
valid_id = /[_A-Za-z][_A-Za-z0-9]*/
identifier = <valid_id  > { text.to_sym }
string = '\'' < /[^']*/ > '\'' { QuotedString.new(text) }
          | '"' < /[^"]*/ > '"' {StringLiteral.new(text) }

variable =  ':' < valid_id > { Deref.new(text.to_sym) }
bare_string =  < /[\/\.\-_0-9A-Za-z][\/\.\-\{\}:_0-9A-Za-z]*/ > { StringLiteral.new(text) }
glob = < /[\/\.\-\*_0-9A-Za-z][\/\.\-\*\{\}:_0-9A-Za-z]*/ > { Glob.new(StringLiteral.new(text)) }
 argument = glob:g { g }
          | string:s { Argument.new(s) }
          | bare_string:s { Argument.new(s) }
          | variable:v { Argument.new(v) }
          

argument_list = argument_list:a1 argument_list:a2 { a1 + a2 }
          | space+ argument:a { [ a ] }

assignment = identifier:i '=' argument:a { Assignment.new(i, a) }
assignment_list = assignment_list:a1 space+ assignment_list:a2 { a1 + a2 }
          | assignment:a { [ a ] }

# comments
comment = '#' not_nl*

# command
simple_command = identifier:i { i }

command = simple_command:c argument_list:a { Command.new(command_name:c, arguments:ArgumentList.new(a)) }
          | simple_command:c { Command.new(command_name:c)  }

# statement
statement = assignment_list:a space+ command:c { Statement.new(assignments:AssignmentList.new(a), command:c) }
          | assignment_list:a { Statement.new(assignments:AssignmentList.new(a)) }
          | command:c { Statement.new(command:c) }

redirect_expr = redirect_op:r - argument:a space+ statement:s { RedirectedStatement.new(r, a, s) }
          | statement:s - redirect_op:r - argument:a { RedirectedStatement.new(r, a, s) }
          | statement:s { s }


statement_list = statement_list:s1 - ';' - statement_list:s2 { s1 + s2 }
          | statement_list:s1 - nl - statement_list:s2 { s1 + s2 }
          | redirect_expr:r? - comment? { [ r ] }


block = statement_list:s { Block.new(s) }

# main entry to root of grammar
#root = statement_list:x { @result = x }
root = block:x { @result = x }
#root = argument:x { @result = x }
