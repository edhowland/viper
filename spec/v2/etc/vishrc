mount /v
mkdir /v/buf
mkdir /v/clip
mkdir /v/search
mkbuf /v/search/buf
proj=:pwd
function newb(file) { mkbuf /v/buf/:{file} }
function open.new(fname) {
bname=:(basename :fname)
newb :bname
_buf=/v/buf/:{bname}
cd :_buf
global _buf
touch .pathname; realpath :fname > .pathname
 }
function open.file(fname) {
bname=:(basename :fname)
newb :bname
cat < :fname > /v/buf/:{bname}
_buf=/v/buf/:{bname}
cd :_buf
global _buf
touch .pathname; realpath :fname > .pathname
}
function open(fname) { (test -f :fname && open.file :fname) || (open.new :fname; echo new file) }
function mkclip(num) { mkbuf /v/clip/:{num} }
alias l="echo *"
mkclip 0
function yank(depth) { subtree :depth > /v/clip/0 }
function put() { cat < /v/clip/0 }
alias c="cat < line"
function paste() { (bottom.buffer && put | appendtree) || put | instree }
function save() { past=:pwd; cd :_buf; cat < :_buf > :(cat < .pathname); cd :past }
alias h="raw -|xfkey"
_mode=viper
function mk.mode(m) { mkdir /v/modes/:{m}; mkdir /v/views/:{m} }
mk.mode viper
mk.mode delete
mk.mode search
indent=2
function neq(a, b) { not { eq :a :b } }
alias ex="echo :exit_status"
function rotate() { shift first; echo :_ :first }
function map() { shift fn; for i in :_ { exec :fn :i } }
function reduce() {
shift fn
shift init
for i in :_ { init=:(exec :fn :init :i) }
echo :init
}
function add(a, b) { ruby 'puts argv[0].to_i + argv[1].to_i' :a :b }
function sub(a, b) { ruby 'puts argv[0].to_i - argv[1].to_i' :a :b }
function incr(a) { add 1 :a }
function count() {
shift fn
_fnx=&(i,j) { (exec :fn :j && incr :i) || echo :i }
reduce :_fnx 0 :_
}
function bell() { ruby 'print "\a"' }
alias scratch="open.new scratch"

