# TODO list for edit_buffer

1. (DONE) FIX moving past the beginning or end of the buffer
2. (DONE) Implement FileBuffer: subclass of Buffer 
  (DONE) initialize takes file name (from ARGV[0]
  (DONE) Implements save command
3. (DONE) move source files to lib/utils or ??
4. (DONE) Figure out cut, copy and paste map to ctrl_x, ctrl_c and ctrl_v
5. (DONE) Implement rudimentary snippet engine hash of keys to array of procs taking Buffer
6. (DONE) Concentrate on up/down line movements. Esp. write specs around many configures of possible buffer configs.
7. (DONE) Implement Search and Reverse-Search.
8. (DONE) Implement Undo/Redo. Use type of CommandBuffer like Buffer (gap buffer)
9. Implement Keyboard Help. Use a special buffer that just speaks the actions.

Misc. 
(DONE) Single command to delete the current line (and cut to clipboard)
(DONE) Command to delete to end of line (copies to clipboard)
(DONE) Command to select the entire buffer. 

Command to delete from current line to bottom of buffer:
  [beg_of_line, set_mark, fin, cut]
  (IMPLEMENTED in REPL) and rewind command - mapped  for now
Implement MultiLineBuffer. up/down moves buffers across gap.
ins/del defer to @a_buff.ins/del
Same for fwd/back, delete to end of line, etc.
When :return, does not insert \n into buffer, returns to command interpreter passing current contents of @a_buff Buffer
Up moves previous buffer into focus, putting the cursor at .fin
Down, moves next buffer (if any, into focus, putting cursor at .beg

