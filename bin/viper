#!/usr/bin/env ruby
# viper - Main entry for Viper editor

require 'pry'
require_relative '../lib/viper'
require 'optparse'


options = {:read_only => false, :check_syntax => false}

parser = OptionParser.new do |opt|
  opt.banner = 'Viper - Editor in Ruby for visually impaired programmers'
  opt.separator '-'
  opt.on('-c', '--check-syntax', 'Check syntax of buffer when exiting') do
    options[:check_syntax] = true
  end
  opt.on('--ro', 'Treat file as Read-only') do
    options[:read_only] = true
  end
  opt.on('-l lineno', '--line lineno', Integer, 'Gotos the lineno in the file') do |lineno|
    options[:line] = lineno
  end
  opt.separator '-'
  opt.on('-h', '--help', 'Displays this help') do
    puts opt
    exit
  end
  opt.on('-v', '--version', 'Displays the version of Viper') do
    puts "Viper VIP Editor in Ruby"
    puts "version #{Viper::VERSION}"
    exit
  end
end

parser.parse!

# possibly open ~/.viperrc and process any commands found there
tmp_buff = ScratchBuffer.new
suppress_audio do
  load_rc do |l|
    parse_execute tmp_buff, l
  end
end

# possibly load ./.viperrc
load_rc './.viperrc', :silent => true do |l|
  parse_execute tmp_buff, l
end
# set up the buffer ring
#@buffer_ring = []
if ARGV.length == 0
  $buffer_ring <<  FileBuffer.new('Unnamed')
else
  if options[:read_only]
    $buffer_ring = ARGV.map {|f| ReadOnlyFileBuffer.new(f) }
  else
    $buffer_ring = ARGV.map {|f| FileBuffer.new(f) }
  end
end

# return the head of the @buffer_ring
def fbuffer
 $buffer_ring.first
end


@buffer = fbuffer
@sbuffer = SnippetBuffer.new ''
@search_buffer = Buffer.new ''
@search_line = Viper::Readline.new
@command_line = Viper::Readline.new
@search_direction = :srch_fwd  # or :srch_back
@search_buffer.name = 'Search buffer'

def swap buff1, buff2
  [buff2, buff1]
end



# possibly jump to a specific line in the file
unless options[:line].nil?
  fbuffer.goto options[:line]
end

# Executes this block for each character typed in the console
#   Exits whenever some exception is raised
 Viper::Control.loop do |worker|
  ch = worker.getch
  prc = worker.bound_proc_for ch
  begin
    result = prc.call(@buffer)
    case result
    when :quit
      break

    when :rotate_buffer
      $buffer_ring.rotate!
      @buffer = fbuffer
      say "Buffer is now #{@buffer.name}"
    when :save
      @buffer.save
      say "Buffer #{@buffer.name} saved"
      when :meta
        say 'meta'
        next_key = map_key(key_press)
        case next_key
        when :key_d
          @buffer.front_of_line; @buffer.set_mark; @buffer.down; $clipboard = @buffer.cut
          say 'line deleted'
        when :shift_end
          @buffer.set_mark; @buffer.back_of_line; $clipboard = @buffer.cut
          say 'delete to end of line'
        when :shift_home
          @buffer.set_mark; @buffer.front_of_line; $clipboard = @buffer.cut
          say 'delete to start of line'
        when :shift_pgup
          @buffer.set_mark; @buffer.beg; $clipboard = @buffer.cut
          say 'delete to top of buffer'
        when :shift_pgdn
          @buffer.set_mark; @buffer.fin; $clipboard = @buffer.cut
          say 'delete to bottom of buffer'
        else
        say next_key.to_s
        end

      when :debug
        say 'Entering debug mode. Press Ctrl-D to exit'
        binding.pry
        say "Exited debug mode. Buffer is #{@buffer.name}"
      when :help
        say "Use Option semicolon and help to invoke help"
    when :snippet_record
      if @sbuffer.kind_of? SnippetBuffer
        @sbuffer.clear
        @sbuffer.name = @buffer.lline
        unless $snippets[@sbuffer.name].nil?
          playback @sbuffer, @sbuffer.name
        end
        @buffer, @sbuffer = swap @buffer, @sbuffer
        say "Now recording snippet: #{@buffer.name}"
      else
        @buffer, @sbuffer = swap @buffer, @sbuffer
        say "Buffer now is #{@buffer.name}"
      end
    when :snippet_playback
      snip_key = @buffer.lline
      if snip_key.empty?
        say BELL
      else
        @buffer.lline.length.times { @buffer.del }
        playback @buffer, snip_key
        say @buffer.line
      end
    when :srch_fwd
      @search_direction = :srch_fwd
      say'search forward'
      pattern = @search_line.readline
      @buffer.srch_fwd(pattern)
      say @buffer.line

    when :srch_back
      @search_direction = :srch_back
      say 'search back'
      pattern = @search_line.readline
      @buffer.srch_back(pattern)
      say @buffer.line

    when :srch_next
      pattern = @search_line.last_line
      if @search_direction == :srch_fwd
        @buffer.fwd
        @buffer.srch_fwd(pattern)
      else
        @buffer.srch_back(pattern)
      end
      say @buffer.line

    when :command
      say 'command '
      command_s = @command_line.readline
      quitting = parse_execute @buffer, command_s
      end
      break if quitting == :quit
      @buffer = fbuffer # restore the @buffer pointer
  rescue BufferExceeded => err
    say BELL
  rescue => err
    say err.message
  end
end

# possibly save dirty buffer
$buffer_ring.select {|b| b.should_save? }.map do |buf|
if confirm?("Save #{buf.name}? ")
 buf.save 
  say "#{buf.name} saved"
end
end

# possibly check syntax of buffer
check_ruby_syntax(fbuffer) if options[:check_syntax]
